import groovy.transform.Memoized

plugins {
    id 'java'
    id 'application'
    id 'org.graalvm.buildtools.native' version '0.10.3'
    id 'com.github.ben-manes.versions' version '0.46.0'
    id 'net.ltgt.errorprone' version '4.2.0'
    id 'io.spring.dependency-management' version '1.1.6'
}

group = 'org.hyperledger.besu.riscv'
version = calculateVersion()

def besuVersion = '25.9.0'

repositories {
    mavenCentral()
    maven {
        url = 'https://hyperledger.jfrog.io/hyperledger/besu-maven'
        content { includeGroupByRegex('org\\.hyperledger\\..*') }
    }
    maven {
        url = 'https://artifacts.consensys.net/public/maven/maven/'
        content { includeGroupByRegex('tech\\.pegasys(\\..*)?') }
    }
    mavenLocal()
}

apply from: "${rootDir}/gradle/versions.gradle"

java {
    withSourcesJar()
    withJavadocJar()
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    mainClass = 'org.hyperledger.besu.riscv.poc.NativeImageTestRunner'
}

// Task to extract native libraries from gnark static JAR
tasks.register('extractGnarkNativeLibs', Copy) {
    def gnarkConfig = configurations.runtimeClasspath
    def gnarkStaticJar = gnarkConfig.files.find { it.name.contains('gnark') && it.name.contains('static') }

    if (gnarkStaticJar) {
        from(zipTree(gnarkStaticJar)) {
            include 'lib/**/*.a'
            include 'lib/**/*.h'
        }
        into layout.buildDirectory.dir('native-libs')
    }
}

// Detect platform for library path, with override for cross-compilation
def detectPlatform() {
    // Check for explicit override first (for cross-compilation via Gradle project property)
    def overrideArch = project.findProperty('CROSS_COMPILE_ARCH')
    if (overrideArch) {
        println "Using cross-compile architecture override: ${overrideArch}"
        return overrideArch
    }

    // Auto-detect based on current platform
    def osName = System.getProperty('os.name').toLowerCase()
    def osArch = System.getProperty('os.arch').toLowerCase()

    if (osName.contains('mac')) {
        if (osArch.contains('aarch64') || osArch.contains('arm')) {
            return 'aarch64'
        } else {
            return 'x86-64'
        }
    } else if (osName.contains('linux')) {
        if (osArch.contains('aarch64') || osArch.contains('arm')) {
            return 'aarch64'
        } else if (osArch.contains('riscv')) {
            return 'riscv64'
        } else {
            return 'x86-64'
        }
    }
    return 'x86-64' // default
}

graalvmNative {
    binaries {
        main {
            imageName = 'nativeImageTestRunner'
            mainClass = 'org.hyperledger.besu.riscv.poc.NativeImageTestRunner'

            // Use specific GraalVM installation
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(21)
                vendor = JvmVendorSpec.GRAAL_VM
            }

            buildArgs.add('--verbose')
            buildArgs.add('--no-fallback')
            buildArgs.add('-H:+ReportExceptionStackTraces')
            buildArgs.add('--enable-all-security-services')
            buildArgs.add('--initialize-at-run-time=org.bouncycastle.jcajce.provider.drbg.DRBG$Default,org.bouncycastle.jcajce.provider.drbg.DRBG$NonceAndIV')
            buildArgs.add('-H:+AddAllCharsets')

            // Add paths for static libraries
            def platform = detectPlatform()
            def nativeLibDir = layout.buildDirectory.dir("native-libs/lib/${platform}").get().asFile
            buildArgs.add("-H:CLibraryPath=${nativeLibDir.absolutePath}")

            // Link against the gnark static libraries
            buildArgs.add("-H:NativeLinkerOption=-lgnark_jni")
            buildArgs.add("-H:NativeLinkerOption=-lgnark_eip_196")
            buildArgs.add("-H:NativeLinkerOption=-lgnark_eip_2537")

            // Honor NATIVE_IMAGE_OPTIONS project property (passed via -PNATIVE_IMAGE_OPTIONS="...")
            // This is used for cross-compilation with LLVM backend or other experimental options
            def nativeImageOptions = project.findProperty('NATIVE_IMAGE_OPTIONS')

            println "=========================================="
            println "GraalVM Native Image Build Configuration"
            println "Target platform: ${platform}"
            println "CROSS_COMPILE_ARCH property: '${project.findProperty('CROSS_COMPILE_ARCH')}'"
            println "NATIVE_IMAGE_OPTIONS property: '${nativeImageOptions}'"

            if (nativeImageOptions) {
                println "Parsing and adding NATIVE_IMAGE_OPTIONS to buildArgs"
                def parsedOptions = nativeImageOptions.toString().trim().split(/\s+/)
                parsedOptions.each { option ->
                    if (option && !option.isEmpty()) {
                        println "  Adding: ${option}"
                        buildArgs.add(option)
                    }
                }
            } else {
                println "NATIVE_IMAGE_OPTIONS not set (use -PNATIVE_IMAGE_OPTIONS=\"...\" to set)"
            }
            println "Total buildArgs count: ${buildArgs.size()}"
            println "=========================================="
        }
    }

    toolchainDetection = false
}

// Make nativeCompile depend on extracting the libraries
tasks.named('nativeCompile') {
    dependsOn 'extractGnarkNativeLibs'
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

@Memoized
def calculateVersion() {
    String version = System.getenv("TAG_VERSION") ?: '1.0-SNAPSHOT'
    // Regex pattern for basic calendar versioning, with provision to omit patch rev
    def versionPattern = ~/\d+\.\d+(\.\d+)?(-.*)?/
    if (! (version =~ versionPattern)) {
        println("Supplied project version is malformed: ${version}, aborting")
        throw new GradleException("Supplied project version is malformed: ${version}")
    }

    if (version.endsWith("-SNAPSHOT")) {
        version = version.replace("-SNAPSHOT", "-dev-" + getCheckedOutGitCommitHash())
    }
    return version
}

@Memoized
def getCheckedOutGitCommitHash() {
    def gitFolder = "${rootDir}/.git/"
    if (!file(gitFolder).exists()) {
        return "unknownCommit"
    }

    try {
        def takeFromHash = 8
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', 'HEAD'
            standardOutput = stdout
            errorOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }
        return stdout.toString().trim().take(takeFromHash)
    } catch (Exception e) {
        return "unknownCommit"
    }
}
