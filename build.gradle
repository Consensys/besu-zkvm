import groovy.transform.Memoized

plugins {
    id 'java'
    id 'application'
    id 'org.graalvm.buildtools.native' version '0.10.3'
    id 'com.github.ben-manes.versions' version '0.46.0'
    id 'net.ltgt.errorprone' version '4.2.0'
    id 'io.spring.dependency-management' version '1.1.6'
}

group = 'org.hyperledger.besu.riscv'
version = calculateVersion()

def besuVersion = '25.9.0'

repositories {
    mavenCentral()
    maven {
        url = 'https://hyperledger.jfrog.io/hyperledger/besu-maven'
        content { includeGroupByRegex('org\\.hyperledger\\..*') }
    }
    maven {
        url = 'https://artifacts.consensys.net/public/maven/maven/'
        content { includeGroupByRegex('tech\\.pegasys(\\..*)?') }
    }
    mavenLocal()
}

apply from: "${rootDir}/gradle/versions.gradle"

java {
    withSourcesJar()
    withJavadocJar()
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    //mainClass = 'org.hyperledger.besu.riscv.poc.GenR1TestCase'
    mainClass = 'org.hyperledger.besu.riscv.poc.GraalG2PointTest'
}

// Task to extract native libraries from gnark static JAR
tasks.register('extractGnarkNativeLibs', Copy) {
    def gnarkConfig = configurations.runtimeClasspath
    def gnarkStaticJar = gnarkConfig.files.find { it.name.contains('gnark') && it.name.contains('static') }

    if (gnarkStaticJar) {
        from(zipTree(gnarkStaticJar)) {
            include 'lib/**/*.a'
            include 'lib/**/*.h'
        }
        into layout.buildDirectory.dir('native-libs')
    }
}

// Detect platform for library path
def detectPlatform() {
    def osName = System.getProperty('os.name').toLowerCase()
    def osArch = System.getProperty('os.arch').toLowerCase()

    if (osName.contains('mac')) {
        if (osArch.contains('aarch64') || osArch.contains('arm')) {
            return 'aarch64'
        } else {
            return 'x86-64'
        }
    } else if (osName.contains('linux')) {
        if (osArch.contains('aarch64') || osArch.contains('arm')) {
            return 'aarch64'
        } else if (osArch.contains('riscv')) {
            return 'riscv64'
        } else {
            return 'x86-64'
        }
    }
    return 'x86-64' // default
}

graalvmNative {
    binaries {
        main {
            //imageName = 'genr1testcase'
            imageName = 'graalg2pointtest'
            mainClass = 'org.hyperledger.besu.riscv.poc.GraalG2PointTest'

            // Use specific GraalVM installation
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(21)
                vendor = JvmVendorSpec.GRAAL_VM
            }

            buildArgs.add('--verbose')
            buildArgs.add('--no-fallback')
            buildArgs.add('-H:+ReportExceptionStackTraces')
            buildArgs.add('--enable-all-security-services')
            buildArgs.add('--initialize-at-run-time=org.bouncycastle.jcajce.provider.drbg.DRBG$Default,org.bouncycastle.jcajce.provider.drbg.DRBG$NonceAndIV')
            buildArgs.add('-H:+AddAllCharsets')

            // Add paths for static libraries
            def platform = detectPlatform()
            def nativeLibDir = layout.buildDirectory.dir("native-libs/lib/${platform}").get().asFile
            buildArgs.add("-H:CLibraryPath=${nativeLibDir.absolutePath}")

            // Link against the gnark static libraries
            buildArgs.add("-H:NativeLinkerOption=-lgnark_jni")
            buildArgs.add("-H:NativeLinkerOption=-lgnark_eip_196")
            buildArgs.add("-H:NativeLinkerOption=-lgnark_eip_2537")
        }
    }

    toolchainDetection = false
}

// Make nativeCompile depend on extracting the libraries
tasks.named('nativeCompile') {
    dependsOn 'extractGnarkNativeLibs'
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

@Memoized
def calculateVersion() {
    String version = System.getenv("TAG_VERSION") ?: '1.0-SNAPSHOT'
    // Regex pattern for basic calendar versioning, with provision to omit patch rev
    def versionPattern = ~/\d+\.\d+(\.\d+)?(-.*)?/
    if (! (version =~ versionPattern)) {
        println("Supplied project version is malformed: ${version}, aborting")
        throw new GradleException("Supplied project version is malformed: ${version}")
    }

    if (version.endsWith("-SNAPSHOT")) {
        version = version.replace("-SNAPSHOT", "-dev-" + getCheckedOutGitCommitHash())
    }
    return version
}

@Memoized
def getCheckedOutGitCommitHash() {
    def gitFolder = "${rootDir}/.git/"
    if (!file(gitFolder).exists()) {
        return "unknownCommit"
    }

    try {
        def takeFromHash = 8
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', 'HEAD'
            standardOutput = stdout
            errorOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }
        return stdout.toString().trim().take(takeFromHash)
    } catch (Exception e) {
        return "unknownCommit"
    }
}
